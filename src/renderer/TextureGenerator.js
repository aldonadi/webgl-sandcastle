export class TextureGenerator {
    constructor(gl) {
        this.gl = gl;
        this.defaultTexture = this.createSolidTexture(1, 1, '#ffffff');
    }

    createSolidTexture(width, height, color) {
        return this.createTexture(width, height, { color });
    }

    /**
     * Generates a procedural texture based on options.
     */
    createTexture(width, height, options = {}) {
        const canvas = document.createElement('canvas');
        canvas.width = width;
        canvas.height = height;
        const ctx = canvas.getContext('2d');

        if (options.sand) {
            // Sand Base Color
            ctx.fillStyle = '#C2B280'; // Sand color
            ctx.fillRect(0, 0, width, height);

            // Heavy Noise for Sand Grains
            this.applyNoise(ctx, width, height, 0.3);

        } else if (options.gradient) {
            let grad;
            if (options.gradient.dir === 'h') {
                grad = ctx.createLinearGradient(0, 0, width, 0);
            } else {
                grad = ctx.createLinearGradient(0, 0, 0, height);
            }
            grad.addColorStop(0, options.gradient.start || options.color || '#ffffff');
            grad.addColorStop(1, options.gradient.end || options.color || '#ffffff');
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, width, height);
        } else {
            ctx.fillStyle = options.color || '#ffffff';
            ctx.fillRect(0, 0, width, height);
        }

        // Noise Overlay
        if (options.noise && !options.sand) {
            this.applyNoise(ctx, width, height, options.noise);
        }

        return this.uploadTexture(canvas, width, height);
    }

    applyNoise(ctx, width, height, amount) {
        const imageData = ctx.getImageData(0, 0, width, height);
        const data = imageData.data;
        const factor = amount * 255;

        for (let i = 0; i < data.length; i += 4) {
            const val = (Math.random() - 0.5) * factor;
            data[i] = Math.min(255, Math.max(0, data[i] + val));
            data[i + 1] = Math.min(255, Math.max(0, data[i + 1] + val));
            data[i + 2] = Math.min(255, Math.max(0, data[i + 2] + val));
        }
        ctx.putImageData(imageData, 0, 0);
    }

    /**
     * Creates a Normal Map from a heightmap generated by noise.
     */
    createNormalMap(width, height, strength = 1.0) {
        const canvas = document.createElement('canvas');
        canvas.width = width;
        canvas.height = height;
        const ctx = canvas.getContext('2d');

        // 1. Generate Height Map (Grayscale Noise)
        const imgData = ctx.createImageData(width, height);
        const data = imgData.data;

        // Perlin noise or just random? Random is too high frequency, maybe smooth it?
        // For sand, high frequency random is actually okay for micro-bumps.
        // Let's create a buffer of heights.
        const heights = new Float32Array(width * height);
        for (let i = 0; i < heights.length; i++) {
            heights[i] = Math.random();
        }
        // Simple blur to make it less jagged?
        // Skip for now, sand is grainy.

        // 2. Compute Gradients (Sobel-like)
        for (let y = 0; y < height; y++) {
            for (let x = 0; x < width; x++) {
                // Get neighbors
                const x0 = (x > 0) ? x - 1 : x;
                const x1 = (x < width - 1) ? x + 1 : x;
                const y0 = (y > 0) ? y - 1 : y;
                const y1 = (y < height - 1) ? y + 1 : y;

                const hL = heights[y * width + x0];
                const hR = heights[y * width + x1];
                const hT = heights[y0 * width + x]; // Top (assuming y goes down? canvas y goes down)
                const hB = heights[y1 * width + x]; // Bottom

                // dx, dy
                const dx = (hR - hL) * strength;
                const dy = (hB - hT) * strength;

                // Normal Vector (-dx, -dy, 1.0)
                let nx = -dx;
                let ny = -dy;
                let nz = 1.0; // Z up in tangent space

                // Normalize
                const len = Math.sqrt(nx * nx + ny * ny + nz * nz);
                nx /= len;
                ny /= len;
                nz /= len;

                // Encode to [0, 255] RGB
                // [-1, 1] -> [0, 1] -> [0, 255]
                const r = (nx * 0.5 + 0.5) * 255;
                const g = (ny * 0.5 + 0.5) * 255;
                const b = (nz * 0.5 + 0.5) * 255;

                const idx = (y * width + x) * 4;
                data[idx] = r;
                data[idx + 1] = g;
                data[idx + 2] = b;
                data[idx + 3] = 255;
            }
        }

        ctx.putImageData(imgData, 0, 0);
        return this.uploadTexture(canvas, width, height);
    }

    /**
     * Creates a circular flare/glow texture.
     */
    createFlareTexture(width, height, options = {}) {
        const canvas = document.createElement('canvas');
        canvas.width = width;
        canvas.height = height;
        const ctx = canvas.getContext('2d');

        const cx = width / 2;
        const cy = height / 2;
        const radius = width / 2;

        const grad = ctx.createRadialGradient(cx, cy, 0, cx, cy, radius);

        const color = options.color || '255, 255, 255'; // RGB string
        const core = options.core || 0.0; // Sharpness of core

        // Gradient: specific to flare type
        // Simple Glow
        grad.addColorStop(0, `rgba(${color}, 1.0)`);
        grad.addColorStop(core, `rgba(${color}, 0.8)`);
        grad.addColorStop(1, `rgba(${color}, 0.0)`);

        ctx.fillStyle = grad;
        ctx.fillRect(0, 0, width, height);

        return this.uploadTexture(canvas, width, height);
    }

    uploadTexture(canvas, width, height) {
        const texture = this.gl.createTexture();
        this.gl.bindTexture(this.gl.TEXTURE_2D, texture);
        this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, this.gl.RGBA, this.gl.UNSIGNED_BYTE, canvas);

        if (this.isPowerOf2(width) && this.isPowerOf2(height)) {
            this.gl.generateMipmap(this.gl.TEXTURE_2D);
            this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.LINEAR_MIPMAP_LINEAR);
        } else {
            this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_S, this.gl.CLAMP_TO_EDGE);
            this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_T, this.gl.CLAMP_TO_EDGE);
            this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.LINEAR);
        }
        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MAG_FILTER, this.gl.LINEAR);
        return texture;
    }

    isPowerOf2(value) {
        return (value & (value - 1)) === 0;
    }
}
